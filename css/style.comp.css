@charset "UTF-8";
:root {
  --color-primary: #eb2f64;
  --color-primary-light: #FF3366;
  --color-primary-dark: #BA265D;
  --color-grey-light-1: #faf9f9;
  --color-grey-light-2: #f4f2f2;
  --color-grey-light-3: #f0eeee;
  --color-grey-light-4: #ccc;
  --color-grey-dark-1: #333;
  --color-grey-dark-2: #777;
  --color-grey-dark-3: #999;
  --shadow-dark: 0 2rem 6rem rgba(0,0,0,.3);
  --shadow-light: 0 2rem 5rem rgba(0,0,0, .06);
  --line: 1px solid var(--color-grey-light-2); }

* {
  margin: 0;
  padding: 0; }

*,
*::before,
*::after {
  box-sizing: inherit; }

html {
  box-sizing: border-box;
  font-size: 62.5%; }
  @media only screen and (max-width: 68.75em) {
    html {
      font-size: 50%;
      /* But now we have another problem, 
        which is that we can now see the pink space, and that's because the 120 rem that we defined for 
        the width of the container are now no longer 1200 pixels, But instead, they are, 120* 8 = 960px
        So that's now only 960 pixels, no longer 1200 pixels. 
        This can be fixed by setting max-width to 100% in the layout for .container */ } }

body {
  font-family: 'Open Sans', sans-serif;
  font-weight: 400;
  line-height: 1.6rem;
  color: var(--color-grey-dark-2);
  background-image: linear-gradient(to right bottom, var(--color-primary-light), var(--color-primary-dark));
  background-size: cover;
  background-repeat: no-repeat;
  min-height: 100vh; }

.container {
  /* The container can decrease if there is not enough space to display 120rem 
       If it's not enough space,i.e. if the view port is less that 1200 pixels, 
       then we simply occupy 100% of the available view port width.*/
  max-width: 120rem;
  margin: 8rem auto;
  background-color: var(--color-grey-light-2);
  box-shadow: var(--shadow-dark);
  min-height: 50rem; }
  @media only screen and (max-width: 75em) {
    .container {
      margin: 0;
      max-width: 100%;
      width: 100%; } }

.header {
  font-size: 1.4rem;
  height: 7rem;
  background-color: #fff;
  border-bottom: var(--line);
  /* In order to put the three elements (logo, search box, user navigation) in the header side by side.
       So the flex container in this case should simply be the parent element of the elements */
  display: flex;
  /* We want the user navigation all the way to the right side, And then search box in the middle. */
  justify-content: space-between;
  /*  We want to align each flex item nicely centered vertically in the header.
        So, if we didn't have Flexbox, we could use like margin-top 
        and would then have to experiment which is the perfect margin.
        But Flexbox makes our lives so much easier and all we have to do is 
        to use the align-items property, which is center the items vertically, i.e. along the cross axis */
  align-items: center;
  /* we want to move the search bar to the last position and on the next line 
    Setting flex-wrap: wrap, now we are allowing the flex items to wrap into a new line 
    if they don't have enough space in the flex container. */ }
  @media only screen and (max-width: 31.25em) {
    .header {
      flex-wrap: wrap;
      align-content: space-around;
      height: 11rem; } }

.content {
  display: flex; }
  @media only screen and (max-width: 56.25em) {
    .content {
      flex-direction: column; } }

.sidebar {
  background-color: var(--color-grey-dark-1);
  /* The property that we use to flexbox to define width is the flex-basis,
       but we should always use it in the shortened flex property. 
       flex-grow: 0; - we don't want the elements to grow even  if there's some space available. 
       flex-shrink: 0; - also we don't want the elements to shrink if there's not enough space.
       flex-basis:18%; - width of the flex item. */
  flex: 0 0 18%;
  display: flex;
  flex-direction: column;
  /* justify-content: space-between
       This divides all the available wide space between the elements 
       and in this case, there are only two elements (.side-nav and .legal) 
       and so, therefore, one is pushed to one side(here top), and other is pushed to the other side (here bottom).*/
  justify-content: space-between; }

.hotel-view {
  background-color: #fff;
  /* We want it to grow as much as it can to over all the available space that it has (100-18% = 82%).
       flex-grow: 1; 
       flex-shrink and flex-basis will be default. */
  flex: 1; }

.detail {
  font-size: 1.4rem;
  display: flex;
  padding: 4.5rem;
  background-color: var(--color-grey-light-1);
  border-bottom: var(--line); }
  @media only screen and (max-width: 56.25em) {
    .detail {
      padding: 3rem; } }
  @media only screen and (max-width: 37.5em) {
    .detail {
      flex-direction: column; } }

.description {
  background-color: #fff;
  box-shadow: var(--shadow-light);
  padding: 3rem;
  flex: 0 0 60%;
  margin-right: 4.5rem; }
  @media only screen and (max-width: 56.25em) {
    .description {
      padding: 2rem;
      margin-right: 3rem; } }
  @media only screen and (max-width: 37.5em) {
    .description {
      margin-right: 0;
      margin-bottom: 3rem; } }

.user-reviews {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center; }

/*
    We will write all the code for all the smaller components into this file.
    These are not really components in the meaning that they're not necessarily really reusable across projects
    but I'm still calling them simply components here because that's the easiest way to do it here.
*/
/*************************************
 LOGO
*/
.logo {
  height: 3.25rem;
  margin-left: 2rem; }

/*************************************
 SEARCH BOX
*/
.search {
  flex: 0 0 40%;
  /* when the input field is not active, we want search button to be at the center of search input element.
      So, of the parent element. The best solution is, once again, to use Flexbox.
      And so you see, each time we want to center something, or to align something, we can always use Flexbox.
      For Flexbox is perfect for all of these small situations where we need to align or center some elements.

      this element is basically a flex-item. And it is becoming a flex container. Nested Flexbox. :)
    */
  display: flex;
  align-items: center;
  justify-content: center;
  /* we want to move the search bar to the third position, so to the last position and on the next line .
    Now, the default value for the order is 0. And that means that right now the logo and the search
    and the user nav all have a order of zero. 
    So if I set the search to order of 1, then it will be the last one. */
  /* set the background color of the button to the same color of when the input is focused, 
       + adjacent sibling. */ }
  @media only screen and (max-width: 31.25em) {
    .search {
      order: 1;
      flex: 0 0 100%;
      background-color: var(--color-grey-light-2); } }
  .search__input {
    /* An input element doesn't inherit the font related proeprties of the global document.
           And so we have to automatically set it to inherit here. */
    font-family: inherit;
    font-size: inherit;
    color: inherit;
    background-color: var(--color-grey-light-2);
    border: none;
    padding: .7rem 2rem;
    border-radius: 100px;
    width: 90%;
    transition: all .2s;
    /* In order to have button on top of input box, 
           we should give the input some negative margin on the right side. 
           This way, the button will move on top of the input. */
    margin-right: -3.25rem;
    /* Basically the placeholder should have lighter text. 
           And when we start typing, it becomes the dark text. */ }
    .search__input:focus {
      outline: none;
      width: 100%;
      background-color: var(--color-grey-light-3); }
    .search__input::-webkit-input-placeholder {
      font-weight: 100;
      color: var(--color-grey-light-4); }
    .search__input::placeholder {
      font-weight: 100;
      color: var(--color-grey-light-4); }
  .search__input:focus + .search__button {
    background-color: var(--color-grey-light-3); }
  .search__button {
    border: none;
    /* the same background color as the input because we basically want it to be like on top of the input.
           in order for that to happen, we should give the input here some negative margin on the right side. */
    background-color: var(--color-grey-light-2); }
    .search__button:focus {
      outline: none; }
    .search__button:active {
      transform: translateY(2px); }
  .search__icon {
    height: 2rem;
    width: 2rem;
    fill: var(--color-grey-dark-3); }

/*************************************
 USER NAVigation
*/
.user-nav {
  /*  user-nav is itself a flex item. 
        All flex items are center aligned as defined in .header's align-items property.
        But we want to override specifically this flex-item. Hence we need o use align-self flex-item property.
        We want to stretch it bcz on hover we want to show grey color for whole box
    */
  align-self: stretch;
  display: flex;
  align-items: center; }
  .user-nav > * {
    padding: 0 2rem;
    cursor: pointer;
    height: 100%;
    /* This is 3rd level of nested flex container.
           header is a flex container, then the user-nav is a flex container,
           and now the icon-box and user as flex containers. */
    display: flex;
    align-items: center; }
  .user-nav > *:hover {
    background-color: var(--color-grey-light-2); }
  .user-nav__icon-box {
    position: relative; }
  .user-nav__icon {
    height: 2.25rem;
    width: 2.25rem;
    fill: var(--color-grey-dark-2); }
  .user-nav__notification {
    font-size: .8rem;
    height: 1.75rem;
    width: 1.75rem;
    border-radius: 50%;
    background-color: var(--color-primary);
    color: #fff;
    position: absolute;
    top: 1.5rem;
    right: 1.1rem;
    /* This is an amazing trick. Flexbox also works with text element.
           Here basically we want to center the text in the rounded pink circle. */
    display: flex;
    justify-content: center;
    align-items: center; }
  .user-nav__user-photo {
    height: 3.75rem;
    border-radius: 50%;
    margin-right: 1rem; }

/*************************************
 SIDE NAVIGATION
*/
.side-nav {
  font-size: 1.4rem;
  list-style: none;
  margin-top: 3.5rem;
  /*  In order to have the animation effect of showing pink box from left to right, 
        we're going to use a before pseudo element, which we basically place before this list item
        and that is the one that will show as soon as we hover on this item.
        so that it will show and then grow to the right side. */
  /* On hovering the mail nav item, the pseudo element should transform and scale on Y direction.
       Also the active state should be exactly the same as the hover state. */
  /* when we click on the item, the color should get a little bit brighter.
       So that at least we have some small active state to show the user that he clicked on the item. */ }
  @media only screen and (max-width: 56.25em) {
    .side-nav {
      display: flex;
      margin: 0; } }
  .side-nav__item {
    position: relative; }
    .side-nav__item:not(:last-child) {
      margin-bottom: .5rem; }
      @media only screen and (max-width: 56.25em) {
        .side-nav__item:not(:last-child) {
          margin-bottom: 0; } }
    @media only screen and (max-width: 56.25em) {
      .side-nav__item {
        flex: 1; } }
  .side-nav__item::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 3px;
    background-color: var(--color-primary);
    transform: scaleY(0);
    /* basically it starts in the middle and then it grows to the sides, 
           and so it grows in the Y direction because we're using scale Y.
           That's because the transform-origin is by default set to center. 
           
           We need to add a delay to the width becausee if we don't, it will simply
           expand immediately and then you'll see it's scaling, but that's not what we want. 

           There's an ability in the transition property to add different settings for different properties.
           i.e. we can have different durations and also different animation timing functions, differemt delays
           for different properties.
           So for width proprety - 
                transition of .4s and
                delay of .2s (which is exactly the time it takes for the first 'transform' transition. )
            
           This way we can have like the staged animations, where first the transform happens 
           and then the width with the delay. */
    transition: transform 0.2s, width 0.4s cubic-bezier(1, 0, 0, 1) 0.2s, background-color 0.1s;
    /* */ }
  .side-nav__item:hover::before, .side-nav__item--active::before {
    transform: scaleY(1);
    width: 100%; }
  .side-nav__item:active::before {
    background-color: var(--color-primary-light); }
  .side-nav__link:link, .side-nav__link:visited {
    color: var(--color-grey-light-1);
    text-decoration: none;
    text-transform: uppercase;
    display: block;
    padding: 1.5rem 3rem;
    z-index: 10;
    position: relative;
    /* side-nav__link and thesvg icon are not aligned properly. so use flexbox. */
    display: flex;
    align-items: center; }
    @media only screen and (max-width: 56.25em) {
      .side-nav__link:link, .side-nav__link:visited {
        justify-content: center;
        padding: 2rem; } }
    @media only screen and (max-width: 37.5em) {
      .side-nav__link:link, .side-nav__link:visited {
        flex-direction: column;
        padding: 1.5rem .5rem; } }
  .side-nav__icon {
    width: 1.75rem;
    height: 1.75rem;
    margin-right: 2rem;
    fill: currentColor; }
    @media only screen and (max-width: 37.5em) {
      .side-nav__icon {
        margin-right: 0;
        margin-bottom: .7rem;
        width: 1.5rem;
        height: 1.5rem; } }

/*************************************
 LEGAL TEXT
*/
.legal {
  font-size: 1.2rem;
  text-align-last: center;
  padding: 2.5rem;
  color: var(--color-grey-light-4); }
  @media only screen and (max-width: 56.25em) {
    .legal {
      display: none; } }

/*************************************
 GALLERY
*/
.gallery {
  /* 
    MODERN WAY -
        To put the figure elements side by side is once again to use flexbox.
    OLD WAY -
        We could also set these images to 1/3, so like to 33.333%, and then use float on these figures here.
        So that would produce the same effect. And then we would have to use a clear fix on the parent(.gallery), 
        and all of that is a bunch of work.
    so, once again, we just use flexbox in order to achieve the same result, 
    So put these images side by side without any clear fix hack or anything like that.
    */
  display: flex; }
  .gallery__photo {
    /*  In responsive design, we also want flexible images.
            And so, we always have to define a width or a height in percentages so that the image stays fluid.
            Also this is required so that it occupies only the width of it's flex-item, oterwise it will overflow. */
    width: 100%;
    display: block; }

/*************************************
 HOTEL OVERVIEW
*/
.overview {
  display: flex;
  align-items: center;
  border-bottom: var(--line); }
  .overview__heading {
    font-size: 2.25rem;
    font-weight: 300;
    text-transform: uppercase;
    letter-spacing: 1px;
    padding: 1.5rem 3rem; }
    @media only screen and (max-width: 37.5em) {
      .overview__heading {
        font-size: 1.8rem;
        padding: 1.25rem 2rem; } }
  .overview__stars {
    /*
        THE PROBLEM:
        With justify-content different options, we will get even or predefined spacing, 
        however sometimes we want uneven or custom alignment of the flex items along the main axis. 
        So in such case, we can’t use justify-content.

        SOLUTION 1:
        We may use flex: 1 for the element which we want to occupy say uneven or custom space. 
        So with flex: 1, that flex item should grow and occupy all the available space.

        PROBLEM WITH SOLUTION 1 (USING flex: 1): 
        This is not ideal, because that flex-item/element should only be the size of its content. We don't want that element to have all of the size (actual size required by the element + All the whitespaces. This can be easily visualized in devtools).
        Imagine that we would have a hover effect on this and then all of that entire element would be hovered. So what we want is a way to create the space on right side of actual stars without actually stretching out that entire element/flex-item. And that is where the power of margin auto comes in.
        
        PROPER SOLUTION (USING margin auto): 
        Use margin: auto (or margin-left: auto or margin-right: auto whichever applicable depending on situation) instead of flex: 1.
        So, the same result, but with our element actually only occupying the space that it needs and then all of the white space is the automatically calculated margin.

        */
    margin-right: auto;
    /* Note: svg icons are sometimes really not 100 percent vertically aligned, 
           if you open devtools and see the svg element and the container in which the svg item is placed,  
           you see that there is like, a small space below each of the svg icon. 
           And that happens because these SVG elements behave like in-line elements, 
           and so it's a bit like text that produces that small white space that we see. 
           We can remove that by setting the line height and the font size to zero for example, 
           but we have a simpler way of doing that by setting their parent element to Flexbox */
    display: flex; }
  .overview__icon-star, .overview__icon-location {
    width: 1.75rem;
    height: 1.75rem;
    fill: var(--color-primary); }
  .overview__location {
    font-size: 1.2rem;
    display: flex;
    align-items: center; }
  .overview__icon-location {
    margin-right: .5rem; }
  .overview__rating {
    background-color: var(--color-primary);
    color: #fff;
    margin-left: 3rem;
    padding: 0 2.25rem;
    align-self: stretch;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center; }
    @media only screen and (max-width: 37.5em) {
      .overview__rating {
        padding: 0 1.5rem; } }
  .overview__rating-average {
    font-size: 2.25rem;
    font-weight: 300; }
    @media only screen and (max-width: 37.5em) {
      .overview__rating-average {
        font-size: 1.8rem; } }
  .overview__rating-count {
    font-size: .8rem;
    text-transform: uppercase; }
    @media only screen and (max-width: 37.5em) {
      .overview__rating-count {
        font-size: .5rem; } }

/*************************************
 BUTTON INLINE
*/
.btn-inline {
  border: none;
  color: var(--color-primary);
  font-size: inherit;
  border-bottom: 1px solid currentColor;
  padding-bottom: 2px;
  display: inline-block;
  background-color: transparent;
  cursor: pointer;
  transition: all .2s; }
  .btn-inline span {
    margin-left: 3px;
    transition: margin-left .2s; }
  .btn-inline:hover {
    color: var(--color-grey-dark-1); }
    .btn-inline:hover span {
      margin-left: 8px; }
  .btn-inline:focus {
    outline: none;
    animation: pulsate 1s infinite; }

/* basically in the beginning nothing happens, 
   then in the middle it is scaled up a little bit, and it has this shadow going on,
   and then in the end it goes back to the normal.*/
@keyframes pulsate {
  0% {
    transform: scale(1);
    box-shadow: none; }
  50% {
    transform: scale(1.05);
    box-shadow: 0 1rem 4rem rgba(0, 0, 0, 0.25); }
  100% {
    transform: scale(1);
    box-shadow: none; } }

/*************************************
 PARAGRAPH
*/
.paragraph:not(:last-of-type) {
  margin-bottom: 2rem; }

/*************************************
 LIST
*/
.list {
  list-style: none;
  margin: 3rem 0;
  padding: 3rem 0;
  border-top: var(--line);
  border-bottom: var(--line);
  display: flex;
  flex-wrap: wrap;
  /* 
        Using SVG directly in CSS 
        In CSS, it's really difficult to use a sprite image like we could in the HTML.
        But in CSS, it's actually much easier to use single icon itself.
        
        How do we actually include an SVG file in our CSS?
        The easiest way is to use a background-image (also the only approach for older browsers). 
        But there is actually a problem with this approach – 
        If we include it as a background image, then we have no way of actually changing the color. But if that's not a problem for your situation, then we can of course go ahead and make it like this.
        
        Another approach - is to use masks (works only in modern browsers)
        Basically a mask defines an area where we can look through the element and see what's behind that element.
        So, basically, what we're going do is to set the background-color of this element to a solid color, and then use the icon as the mask (by putting our mask on top of this, and only in the positions where the icon is).  And so we can then look through that mask, basically, and see the background color in the area where the icon is and everything else is covered,
        So it's basically a bit like clipping (background-clip).
    */ }
  .list__item {
    flex: 0 0 50%;
    margin-bottom: .7rem; }
  .list__item::before {
    /* in order to actually show that svg icon on page, we must provide these properties for the pseudo element
           content, display, height, width. Otherwise the svg will not be shown. */
    content: '';
    display: inline-block;
    height: 1rem;
    width: 1rem;
    margin-right: .7rem;
    background-image: url(../img/chevron-thin-right.svg);
    background-size: cover; }
    @supports (-webkit-mask-image: url()) or (mask-image: url()) {
      .list__item::before {
        background-color: var(--color-primary);
        -webkit-mask-image: url(../img/chevron-thin-right.svg);
        mask-image: url(../img/chevron-thin-right.svg);
        -webkit-mask-size: cover;
        mask-size: cover;
        background-image: none; } }

/*************************************
 RECOMMEND
*/
.recommend {
  font-size: 1.3rem;
  color: var(--color-grey-dark-3);
  display: flex;
  align-items: center; }
  .recommend__count {
    /* same trick as we used for '&__stars' 
        So the margin which was automatically calculated 
        to push the recommend__friends box all the way to the right side. */
    margin-right: auto; }
  .recommend__friends {
    display: flex; }
  .recommend__photo {
    height: 4rem;
    width: 4rem;
    border-radius: 50%;
    border: 3px solid #fff;
    /* Since we have added the border, the border actually goes into these images and the image shrinks.
        we have now two options to fix that, 
            1. We could either add these three pixels on the height and width, 
            2. or we can do it automatically by setting box-sizing: border-box
        For HTML selector, we have set box-sizing to border-box, which includes the padding and the border into the width and height of the element.
        which is usually what we want. 
        However in this particular situation, we want the border to be added on top of our height and the width,
        so we need to set it to content-box (which is the default) */
    box-sizing: content-box;
    /* These images are like on top of each other, like slightly overlapping.
        And we can simply do that by giving them a negative right margin except for the last one.*/ }
    .recommend__photo:not(:last-child) {
      margin-right: -2rem; }

/*************************************
 REVIEWS
*/
.review {
  background-color: #fff;
  box-shadow: var(--shadow-light);
  padding: 3rem;
  margin-bottom: 3.5rem;
  position: relative;
  overflow: hidden; }
  @media only screen and (max-width: 56.25em) {
    .review {
      padding: 2rem;
      margin-bottom: 3rem; } }
  .review__text {
    margin-bottom: 2rem;
    z-index: 10;
    position: relative; }
  .review__user {
    display: flex;
    align-items: center; }
  .review__photo {
    height: 4.5rem;
    width: 4.5rem;
    border-radius: 50%;
    margin-right: 1.5rem; }
  .review__user-box {
    margin-right: auto; }
  .review__user-name {
    text-transform: uppercase;
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: .4rem; }
  .review__user-date {
    font-size: 1rem;
    color: var(--color-grey-dark-3); }
  .review__rating {
    color: var(--color-primary);
    font-size: 2.2rem;
    font-weight: 300; }
  .review::before {
    content: "\201C";
    position: absolute;
    top: -2.75rem;
    left: -1rem;
    line-height: 1;
    font-size: 20rem;
    color: var(--color-grey-light-2);
    font-family: sans-serif;
    z-index: 1; }

/*************************************
 CALL TO ACTION (CTA)
*/
.cta {
  padding: 3.5rem 0;
  text-align: center; }
  @media only screen and (max-width: 56.25em) {
    .cta {
      padding: 2.5rem 0; } }
  .cta__book-now {
    text-transform: uppercase;
    font-size: 2rem;
    font-weight: 300;
    margin-bottom: 2.5rem; }

/*************************************
 BUTTON - CALL TO ACTION (CTA)
*/
.btn {
  font-size: 1.5rem;
  font-weight: 300;
  text-transform: uppercase;
  border: none;
  border-radius: 100px;
  background-image: linear-gradient(to right, var(--color-primary-light), var(--color-primary));
  color: #fff;
  position: relative;
  overflow: hidden;
  cursor: pointer; }
  .btn > * {
    display: inline-block;
    height: 100%;
    width: 100%;
    transition: all .2s; }
  .btn__visible {
    padding: 2rem 7.5rem; }
  .btn__invisible {
    position: absolute;
    padding: 2rem 0;
    left: 0;
    /* to move up exactly the size of the element. So basically if this element is like 50 pixels high,
           it will move up 100% of that. And so 50 pixels. */
    top: -100%; }
  .btn:hover {
    background-image: linear-gradient(to left, var(--color-primary-light), var(--color-primary)); }
  .btn:hover .btn__visible {
    transform: translateY(100%); }
  .btn:hover .btn__invisible {
    top: 0; }
  .btn:focus {
    outline: none;
    animation: pulsate 1s infinite; }
